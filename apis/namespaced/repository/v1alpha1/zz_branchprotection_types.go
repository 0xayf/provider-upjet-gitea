// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by upjet. DO NOT EDIT.

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime/schema"

	v1 "github.com/crossplane/crossplane-runtime/v2/apis/common/v1"
	v2 "github.com/crossplane/crossplane-runtime/v2/apis/common/v2"
)

type BranchProtectionInitParameters struct {

	// Only reviews from allowlisted teams will count to the required
	// approvals. Without approval allowlist, reviews from anyone with
	// write access count to the required approvals.
	ApprovalWhitelistTeams []*string `json:"approvalWhitelistTeams,omitempty" tf:"approval_whitelist_teams,omitempty"`

	// Only reviews from allowlisted users will count to the required
	// approvals. Without approval allowlist, reviews from anyone with
	// write access count to the required approvals.
	ApprovalWhitelistUsers []*string `json:"approvalWhitelistUsers,omitempty" tf:"approval_whitelist_users,omitempty"`

	// Merging will not be possible when it has official
	// review requests, even if there are enough approvals.
	BlockMergeOnOfficialReviewRequests *bool `json:"blockMergeOnOfficialReviewRequests,omitempty" tf:"block_merge_on_official_review_requests,omitempty"`

	// Merging will not be possible when head branch is behind base branch.
	BlockMergeOnOutdatedBranch *bool `json:"blockMergeOnOutdatedBranch,omitempty" tf:"block_merge_on_outdated_branch,omitempty"`

	// Merging will not be possible when changes are
	// requested by official reviewers, even if there are enough
	// approvals.
	BlockMergeOnRejectedReviews *bool `json:"blockMergeOnRejectedReviews,omitempty" tf:"block_merge_on_rejected_reviews,omitempty"`

	// When new commits that change the content of the pull request
	// are pushed to the branch, old approvals will be dismissed.
	DismissStaleApprovals *bool `json:"dismissStaleApprovals,omitempty" tf:"dismiss_stale_approvals,omitempty"`

	// Anyone with write access will be allowed to push to this branch
	// (but not force push), add a whitelist users or teams to limit
	// access.
	EnablePush *bool `json:"enablePush,omitempty" tf:"enable_push,omitempty"`

	// Allow only allowlisted teams to merge pull requests into this branch.
	MergeWhitelistTeams []*string `json:"mergeWhitelistTeams,omitempty" tf:"merge_whitelist_teams,omitempty"`

	// Allow only allowlisted users to merge pull requests into this branch.
	MergeWhitelistUsers []*string `json:"mergeWhitelistUsers,omitempty" tf:"merge_whitelist_users,omitempty"`

	// Repository name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Protected file patterns (separated using semicolon ';')
	ProtectedFilePatterns *string `json:"protectedFilePatterns,omitempty" tf:"protected_file_patterns,omitempty"`

	// Allow deploy keys with write access to push. Requires enable_push to be set to true.
	PushWhitelistDeployKeys *bool `json:"pushWhitelistDeployKeys,omitempty" tf:"push_whitelist_deploy_keys,omitempty"`

	// Allowlisted teams for pushing. Requires enable_push to be set to true.
	PushWhitelistTeams []*string `json:"pushWhitelistTeams,omitempty" tf:"push_whitelist_teams,omitempty"`

	// Allowlisted users for pushing. Requires enable_push to be set to true.
	PushWhitelistUsers []*string `json:"pushWhitelistUsers,omitempty" tf:"push_whitelist_users,omitempty"`

	// Reject pushes to this branch if they are unsigned or unverifiable.
	RequireSignedCommits *bool `json:"requireSignedCommits,omitempty" tf:"require_signed_commits,omitempty"`

	// Allow only to merge pull request with enough positive reviews.
	RequiredApprovals *float64 `json:"requiredApprovals,omitempty" tf:"required_approvals,omitempty"`

	// Protected Branch Name Pattern
	RuleName *string `json:"ruleName,omitempty" tf:"rule_name,omitempty"`

	// Enter patterns to specify which status checks must pass before
	// branches can be merged into a branch that matches this rule.
	// Each line specifies a pattern. Patterns cannot be empty.
	StatusCheckPatterns []*string `json:"statusCheckPatterns,omitempty" tf:"status_check_patterns,omitempty"`

	// Unprotected file patterns (separated using semicolon ';')
	UnprotectedFilePatterns *string `json:"unprotectedFilePatterns,omitempty" tf:"unprotected_file_patterns,omitempty"`

	// User name or organization name
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type BranchProtectionObservation struct {

	// Only reviews from allowlisted teams will count to the required
	// approvals. Without approval allowlist, reviews from anyone with
	// write access count to the required approvals.
	ApprovalWhitelistTeams []*string `json:"approvalWhitelistTeams,omitempty" tf:"approval_whitelist_teams,omitempty"`

	// Only reviews from allowlisted users will count to the required
	// approvals. Without approval allowlist, reviews from anyone with
	// write access count to the required approvals.
	ApprovalWhitelistUsers []*string `json:"approvalWhitelistUsers,omitempty" tf:"approval_whitelist_users,omitempty"`

	// Merging will not be possible when it has official
	// review requests, even if there are enough approvals.
	BlockMergeOnOfficialReviewRequests *bool `json:"blockMergeOnOfficialReviewRequests,omitempty" tf:"block_merge_on_official_review_requests,omitempty"`

	// Merging will not be possible when head branch is behind base branch.
	BlockMergeOnOutdatedBranch *bool `json:"blockMergeOnOutdatedBranch,omitempty" tf:"block_merge_on_outdated_branch,omitempty"`

	// Merging will not be possible when changes are
	// requested by official reviewers, even if there are enough
	// approvals.
	BlockMergeOnRejectedReviews *bool `json:"blockMergeOnRejectedReviews,omitempty" tf:"block_merge_on_rejected_reviews,omitempty"`

	// Webhook creation timestamp
	CreatedAt *string `json:"createdAt,omitempty" tf:"created_at,omitempty"`

	// When new commits that change the content of the pull request
	// are pushed to the branch, old approvals will be dismissed.
	DismissStaleApprovals *bool `json:"dismissStaleApprovals,omitempty" tf:"dismiss_stale_approvals,omitempty"`

	// True if a approval whitelist is used.
	EnableApprovalWhitelist *bool `json:"enableApprovalWhitelist,omitempty" tf:"enable_approval_whitelist,omitempty"`

	// True if a merge whitelist is used.
	EnableMergeWhitelist *bool `json:"enableMergeWhitelist,omitempty" tf:"enable_merge_whitelist,omitempty"`

	// Anyone with write access will be allowed to push to this branch
	// (but not force push), add a whitelist users or teams to limit
	// access.
	EnablePush *bool `json:"enablePush,omitempty" tf:"enable_push,omitempty"`

	// True if a push whitelist is used.
	EnablePushWhitelist *bool `json:"enablePushWhitelist,omitempty" tf:"enable_push_whitelist,omitempty"`

	// Require status checks to pass before merging. When enabled,
	// commits must first be pushed to another branch, then merged
	// or pushed directly to a branch that matches this rule after
	// status checks have passed. If no contexts are matched, the
	// last commit must be successful regardless of context
	EnableStatusCheck *bool `json:"enableStatusCheck,omitempty" tf:"enable_status_check,omitempty"`

	ID *string `json:"id,omitempty" tf:"id,omitempty"`

	// Allow only allowlisted teams to merge pull requests into this branch.
	MergeWhitelistTeams []*string `json:"mergeWhitelistTeams,omitempty" tf:"merge_whitelist_teams,omitempty"`

	// Allow only allowlisted users to merge pull requests into this branch.
	MergeWhitelistUsers []*string `json:"mergeWhitelistUsers,omitempty" tf:"merge_whitelist_users,omitempty"`

	// Repository name
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Protected file patterns (separated using semicolon ';')
	ProtectedFilePatterns *string `json:"protectedFilePatterns,omitempty" tf:"protected_file_patterns,omitempty"`

	// Allow deploy keys with write access to push. Requires enable_push to be set to true.
	PushWhitelistDeployKeys *bool `json:"pushWhitelistDeployKeys,omitempty" tf:"push_whitelist_deploy_keys,omitempty"`

	// Allowlisted teams for pushing. Requires enable_push to be set to true.
	PushWhitelistTeams []*string `json:"pushWhitelistTeams,omitempty" tf:"push_whitelist_teams,omitempty"`

	// Allowlisted users for pushing. Requires enable_push to be set to true.
	PushWhitelistUsers []*string `json:"pushWhitelistUsers,omitempty" tf:"push_whitelist_users,omitempty"`

	// Reject pushes to this branch if they are unsigned or unverifiable.
	RequireSignedCommits *bool `json:"requireSignedCommits,omitempty" tf:"require_signed_commits,omitempty"`

	// Allow only to merge pull request with enough positive reviews.
	RequiredApprovals *float64 `json:"requiredApprovals,omitempty" tf:"required_approvals,omitempty"`

	// Protected Branch Name Pattern
	RuleName *string `json:"ruleName,omitempty" tf:"rule_name,omitempty"`

	// Enter patterns to specify which status checks must pass before
	// branches can be merged into a branch that matches this rule.
	// Each line specifies a pattern. Patterns cannot be empty.
	StatusCheckPatterns []*string `json:"statusCheckPatterns,omitempty" tf:"status_check_patterns,omitempty"`

	// Unprotected file patterns (separated using semicolon ';')
	UnprotectedFilePatterns *string `json:"unprotectedFilePatterns,omitempty" tf:"unprotected_file_patterns,omitempty"`

	// Webhook creation timestamp
	UpdatedAt *string `json:"updatedAt,omitempty" tf:"updated_at,omitempty"`

	// User name or organization name
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

type BranchProtectionParameters struct {

	// Only reviews from allowlisted teams will count to the required
	// approvals. Without approval allowlist, reviews from anyone with
	// write access count to the required approvals.
	// +kubebuilder:validation:Optional
	ApprovalWhitelistTeams []*string `json:"approvalWhitelistTeams,omitempty" tf:"approval_whitelist_teams,omitempty"`

	// Only reviews from allowlisted users will count to the required
	// approvals. Without approval allowlist, reviews from anyone with
	// write access count to the required approvals.
	// +kubebuilder:validation:Optional
	ApprovalWhitelistUsers []*string `json:"approvalWhitelistUsers,omitempty" tf:"approval_whitelist_users,omitempty"`

	// Merging will not be possible when it has official
	// review requests, even if there are enough approvals.
	// +kubebuilder:validation:Optional
	BlockMergeOnOfficialReviewRequests *bool `json:"blockMergeOnOfficialReviewRequests,omitempty" tf:"block_merge_on_official_review_requests,omitempty"`

	// Merging will not be possible when head branch is behind base branch.
	// +kubebuilder:validation:Optional
	BlockMergeOnOutdatedBranch *bool `json:"blockMergeOnOutdatedBranch,omitempty" tf:"block_merge_on_outdated_branch,omitempty"`

	// Merging will not be possible when changes are
	// requested by official reviewers, even if there are enough
	// approvals.
	// +kubebuilder:validation:Optional
	BlockMergeOnRejectedReviews *bool `json:"blockMergeOnRejectedReviews,omitempty" tf:"block_merge_on_rejected_reviews,omitempty"`

	// When new commits that change the content of the pull request
	// are pushed to the branch, old approvals will be dismissed.
	// +kubebuilder:validation:Optional
	DismissStaleApprovals *bool `json:"dismissStaleApprovals,omitempty" tf:"dismiss_stale_approvals,omitempty"`

	// Anyone with write access will be allowed to push to this branch
	// (but not force push), add a whitelist users or teams to limit
	// access.
	// +kubebuilder:validation:Optional
	EnablePush *bool `json:"enablePush,omitempty" tf:"enable_push,omitempty"`

	// Allow only allowlisted teams to merge pull requests into this branch.
	// +kubebuilder:validation:Optional
	MergeWhitelistTeams []*string `json:"mergeWhitelistTeams,omitempty" tf:"merge_whitelist_teams,omitempty"`

	// Allow only allowlisted users to merge pull requests into this branch.
	// +kubebuilder:validation:Optional
	MergeWhitelistUsers []*string `json:"mergeWhitelistUsers,omitempty" tf:"merge_whitelist_users,omitempty"`

	// Repository name
	// +kubebuilder:validation:Optional
	Name *string `json:"name,omitempty" tf:"name,omitempty"`

	// Protected file patterns (separated using semicolon ';')
	// +kubebuilder:validation:Optional
	ProtectedFilePatterns *string `json:"protectedFilePatterns,omitempty" tf:"protected_file_patterns,omitempty"`

	// Allow deploy keys with write access to push. Requires enable_push to be set to true.
	// +kubebuilder:validation:Optional
	PushWhitelistDeployKeys *bool `json:"pushWhitelistDeployKeys,omitempty" tf:"push_whitelist_deploy_keys,omitempty"`

	// Allowlisted teams for pushing. Requires enable_push to be set to true.
	// +kubebuilder:validation:Optional
	PushWhitelistTeams []*string `json:"pushWhitelistTeams,omitempty" tf:"push_whitelist_teams,omitempty"`

	// Allowlisted users for pushing. Requires enable_push to be set to true.
	// +kubebuilder:validation:Optional
	PushWhitelistUsers []*string `json:"pushWhitelistUsers,omitempty" tf:"push_whitelist_users,omitempty"`

	// Reject pushes to this branch if they are unsigned or unverifiable.
	// +kubebuilder:validation:Optional
	RequireSignedCommits *bool `json:"requireSignedCommits,omitempty" tf:"require_signed_commits,omitempty"`

	// Allow only to merge pull request with enough positive reviews.
	// +kubebuilder:validation:Optional
	RequiredApprovals *float64 `json:"requiredApprovals,omitempty" tf:"required_approvals,omitempty"`

	// Protected Branch Name Pattern
	// +kubebuilder:validation:Optional
	RuleName *string `json:"ruleName,omitempty" tf:"rule_name,omitempty"`

	// Enter patterns to specify which status checks must pass before
	// branches can be merged into a branch that matches this rule.
	// Each line specifies a pattern. Patterns cannot be empty.
	// +kubebuilder:validation:Optional
	StatusCheckPatterns []*string `json:"statusCheckPatterns,omitempty" tf:"status_check_patterns,omitempty"`

	// Unprotected file patterns (separated using semicolon ';')
	// +kubebuilder:validation:Optional
	UnprotectedFilePatterns *string `json:"unprotectedFilePatterns,omitempty" tf:"unprotected_file_patterns,omitempty"`

	// User name or organization name
	// +kubebuilder:validation:Optional
	Username *string `json:"username,omitempty" tf:"username,omitempty"`
}

// BranchProtectionSpec defines the desired state of BranchProtection
type BranchProtectionSpec struct {
	v2.ManagedResourceSpec `json:",inline"`
	ForProvider            BranchProtectionParameters `json:"forProvider"`
	// THIS IS A BETA FIELD. It will be honored
	// unless the Management Policies feature flag is disabled.
	// InitProvider holds the same fields as ForProvider, with the exception
	// of Identifier and other resource reference fields. The fields that are
	// in InitProvider are merged into ForProvider when the resource is created.
	// The same fields are also added to the terraform ignore_changes hook, to
	// avoid updating them after creation. This is useful for fields that are
	// required on creation, but we do not desire to update them after creation,
	// for example because of an external controller is managing them, like an
	// autoscaler.
	InitProvider BranchProtectionInitParameters `json:"initProvider,omitempty"`
}

// BranchProtectionStatus defines the observed state of BranchProtection.
type BranchProtectionStatus struct {
	v1.ResourceStatus `json:",inline"`
	AtProvider        BranchProtectionObservation `json:"atProvider,omitempty"`
}

// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:storageversion

// BranchProtection is the Schema for the BranchProtections API. <no value>
// +kubebuilder:printcolumn:name="SYNCED",type="string",JSONPath=".status.conditions[?(@.type=='Synced')].status"
// +kubebuilder:printcolumn:name="READY",type="string",JSONPath=".status.conditions[?(@.type=='Ready')].status"
// +kubebuilder:printcolumn:name="EXTERNAL-NAME",type="string",JSONPath=".metadata.annotations.crossplane\\.io/external-name"
// +kubebuilder:printcolumn:name="AGE",type="date",JSONPath=".metadata.creationTimestamp"
// +kubebuilder:resource:scope=Namespaced,categories={crossplane,managed,gitea}
type BranchProtection struct {
	metav1.TypeMeta   `json:",inline"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.name) || (has(self.initProvider) && has(self.initProvider.name))",message="spec.forProvider.name is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.ruleName) || (has(self.initProvider) && has(self.initProvider.ruleName))",message="spec.forProvider.ruleName is a required parameter"
	// +kubebuilder:validation:XValidation:rule="!('*' in self.managementPolicies || 'Create' in self.managementPolicies || 'Update' in self.managementPolicies) || has(self.forProvider.username) || (has(self.initProvider) && has(self.initProvider.username))",message="spec.forProvider.username is a required parameter"
	Spec   BranchProtectionSpec   `json:"spec"`
	Status BranchProtectionStatus `json:"status,omitempty"`
}

// +kubebuilder:object:root=true

// BranchProtectionList contains a list of BranchProtections
type BranchProtectionList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	Items           []BranchProtection `json:"items"`
}

// Repository type metadata.
var (
	BranchProtection_Kind             = "BranchProtection"
	BranchProtection_GroupKind        = schema.GroupKind{Group: CRDGroup, Kind: BranchProtection_Kind}.String()
	BranchProtection_KindAPIVersion   = BranchProtection_Kind + "." + CRDGroupVersion.String()
	BranchProtection_GroupVersionKind = CRDGroupVersion.WithKind(BranchProtection_Kind)
)

func init() {
	SchemeBuilder.Register(&BranchProtection{}, &BranchProtectionList{})
}
